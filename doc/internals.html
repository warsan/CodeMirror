<!doctype html>

<title>CodeMirror: внутренние элемены</title>
<meta charset="utf-8"/>
<link rel=stylesheet href="docs.css">
<style>dl dl {margin: 0;} .update {color: #d40 !important}</style>
<script src="activebookmark.js"></script>

<div id=nav>
  <a href="https://codemirror.net"><h1>CodeMirror</h1><img id=logo src="logo.png"></a>

  <ul>
    <li><a href="../index.html">Домой</a>
    <li><a href="manual.html">Инструкция</a>
    <li><a href="https://github.com/codemirror/codemirror">Код</a>
  </ul>
  <ul>
    <li><a href="#top">Вступление</a></li>
    <li><a href="#approach">Основной подход</a></li>
    <li><a href="#input">Ввод</a></li>
    <li><a href="#selection">Выбор</a></li>
    <li><a href="#update">Интеллектуальное Обновление</a></li>
    <li><a href="#parse">Парсинг</a></li>
    <li><a href="#summary">Что даёт?</a></li>
    <li><a href="#btree">Представление контента</a></li>
    <li><a href="#keymap">Ключевые карты</a></li>
  </ul>
</div>

<article><h2 id=top>(Re-) Implementing A Syntax-Highlighting Editor in JavaScript</h2>

  <p style="font-size: 85%" id="intro">
    <strong>Тема:</strong> JavaScript, реализация редактора кода<br>
    <strong>Автор:</strong> Marijn Haverbeke<br>
    <strong>Дата::</strong> 2 марта 2011 г. (обновлено 13 ноября 2011 г.)
  </p>
  <p style="padding: 0 3em 0 2em"><strong>Осторожно</strong>: этот текст был написан вскоре после того, как была написана версия 2. 
    Она больше не представляет в полной мере (даже включая обновление в нижней части) текущую реализацию. 
    Я оставляю его здесь как исторический документ. Для получения более свежей информации просмотрите записи с метками 
  <a href="http://marijnhaverbeke.nl/blog/#cm-internals">cm-internals</a> в моем блоге.
  </p>

  <p>Это продолжение моей <a href="https://codemirror.net/story.html">Жестокой Одиссеи к Темной Стороне Дерева DOM</a>. 
    Это описывает умопомрачительный процесс реализации (чем бы он стал) CodeMirror 1.
    Это описывает внутреннюю часть CodeMirror 2, полное переписывание и переосмысление старой кодовой базы. 
    Я хотел дать этой части еще один подражатель субтитров Хантера Томпсона, но каким-то образом это было бы неуместно - процесс на этот раз был одним из простых инжинирингов, не требующих никакого серьезного сгибания ума.
  </p>
  <p>Итак, что не так с Кодовым Зеркалом 1? 
    Я бы оценил по активности списков рассылки и общему наличию поисковых систем, что к настоящему времени он интегрирован примерно в тысячу систем.  
    Самый известный, с нескольких недель, 
  <a href="http://googlecode.blogspot.com/2011/01/make-quick-fixes-quicker-on-google.html">хостинг проекта Google Code</a>. 
  Он работает, и широко используется.
  </p>
  <p>Тем не менее, я не стал его заменять, потому что мне было скучно. CodeMirror 1 сильно зависел от <code>designMode</code> или <code>contentEditable</code> (в зависимости от браузера). 
    Ни то, ни другое не указано четко (HTML5 пытается указать 
  <a href="http://www.w3.org/TR/html5/editing.html#contenteditable">непонятные</a> и баггированные области функциональности браузера — CodeMirror, используя эту функциональность нестандартным образом, постоянно сталкивался с ошибками в работе браузера. 
    WebKit не показывал пустую строку в конце документа, а в некоторых релизах вдруг становился невыносимо медленным. 
    Firefox покажет курсор не в том месте.
    Internet Explorer будет настаивать на привязке к ссылкам всего, что выглядит как URL или адрес электронной почты, - поведение, которое нельзя отключить. 
    Некоторые ошибки мне удалось обойти (что часто было разочаровывающим, болезненным процессом), другие, такие как размещение курсора Firefox, я сдался, и должен был сказать пользователю за пользователем, что это известные проблемы, но не те, где я мог бы помочь.
  </p>
  <p>Также существует тот факт, что <code>designMode</code> (который казался менее баггичным, чем <code>contentEditable</code> в Webkit и Firefox, и, таким образом, использовался CodeMirror 1 в этих браузерах) требует фрейма. 
    Фреймы - это еще одна сложная область. Нужно приложить некоторые усилия, чтобы не запутаться в ограничениях домена, они не инициализируются синхронно, ведут себя странно в ответ на кнопку "назад", и, в некоторых браузерах, не могут быть перемещены по DOM без их повторной инициализации. 
    Они действительно обеспечили очень хороший способ для пространства имен библиотеки, хотя CodeMirror 1 мог свободно загрязнять пространство имен внутри фрейма. 
  </p>
  <p>Наконец, работа с редактируемым документом означает работу с выделениями в произвольных структурах DOM. Internet Explorer (8 и ранее) имеет совершенно другой (и неудобный) API выбора, чем все другие браузеры, и даже среди различных реализаций <code>document.selection</code>, подробности о том, как именно представлена выборка, сильно варьируются. 
    Добавьте к этому тот факт, что до недавнего времени поддержка селекции в Opera была очень баггична, и вы можете себе представить, почему CodeMirror 1 содержит 700 строк кода селекции-обработки.
  </p>
  <p>И это подводит нас к основной проблеме с кодовой базой CodeMirror 1: 
	Доля обходных путей браузера к реальному коду приложения становилась опасно высокой. 
	Построив систему на нескольких изворотливых функциях, я поставил ее в уязвимое положение - любая несовместимость и ошибки в этих функциях привели к тому, что мне пришлось записать свой собственный код. 
    Мало того, что мне приходилось делать серьезные трюки, чтобы заставить его работать на старых браузерах (о чем подробно говорилось в 
  <a href="https://codemirror.net/story.html">предыдущей истории</a>), еще и новые версии продолжали ломаться, требуя от меня <em>новых</em> страшных взломов, чтобы не отставать. Это начало терять свою привлекательность.
  </p>
<section id=approach><h2>Основной подход</h2>
  <p>CodeMirror 2 пытается обойти большинство хитростей, появившихся в версии 1. 
	Я многим обязан редактору
  <a href="http://ace.ajax.org">ACE</a> за то, что он вдохновил меня, как подойти к этому. 
  </p>
  <p>Я абсолютно не хотел полностью полагаться на ключевые события при формировании своего вклада. 
	Каждый программист на JavaScript знает, что информация о ключевых событиях ужасна и неполна. Некоторым людям (особенно Михаю Базону с  
    <a href="http://ymacs.org">Ymacs</a>) удалось создать более или менее функционирующие редакторы, непосредственно читая ключевые события, но это требует много работы (бесконечная и хрупкая работа, которую я описал ранее), и они будут никогда не сможет должным образом поддерживать такие вещи, как ввод международных символов с помощью нескольких клавиш.
    <a href="#keymap" class="update">[см. предостережение ниже]</a>
  </p>
  <p>Итак, что я делаю, это фокусирую скрытое текстовое поле и позволяю браузеру полагать, что пользователь вводит в него. 
	Мы показываем пользователю структуру DOM, которую мы создали для представления его документа. 
	Если он обновляется достаточно быстро и показывает какой-то правдоподобный курсор, это похоже на настоящий элемент управления вводом текста.
  </p>
  <p>Еще одна большая победа в том, что это представление DOM не обязательно должно охватывать весь документ. 
	Некоторые пользователи CodeMirror 1 настаивали на том, что им нужно поместить в CodeMirror XML-документ на 30 тысяч строк. 
    Помещение всего этого в DOM требует времени, тем более что по какой-то причине редактируемое дерево DOM работает медленнее, чем нормальное, в большинстве браузеров. 
    Если у нас есть полный контроль над тем, что мы показываем, мы должны только убедиться, что видимая часть документа была добавлена, а остальное можем сделать только при необходимости. (К счастью, событие <code>onscroll</code> работает почти одинаково во всех браузерах и позволяет отображать объекты только по мере их прокрутки.)
  </p>
</section>
<section id="input"><h2>Ввод</h2>
  <p>ACE использует свою скрытую текстовую область только в качестве оболочки ввода текста и выполняет все перемещения курсора и такие вещи, как удаление текста, непосредственно обрабатывая ключевые события. Способ CodeMirror заключается в том, чтобы позволить браузеру делать свое дело как можно больше, а не, например, определять свой собственный набор Привязок ключей. 
Один из способов сделать это состоял бы в том, чтобы иметь весь документ внутри скрытой текстовой области и после каждого ключевого события обновлять Display DOM, чтобы отразить то, что находится в этой текстовой области.
  </p>
  <p>Это было бы просто, но это не реалистично. 
Для документа даже среднего размера редактор будет постоянно жевать огромные строки и становиться ужасно медленным. 
Что делает CodeMirror 2, так это помещает текущий выбор вместе с дополнительной строкой сверху и снизу в текстовую область.
  </p>
  <p>Это означает, что клавиши со стрелками (и их ctrl-вариации), home, end и т. д., не должны обрабатываться специально. 
Мы просто читаем положение курсора в текстовой области и обновляем наш курсор, чтобы соответствовать ему. 
Кроме того, копирование и вставка работают в значительной степени бесплатно, и люди получают свои собственные привязки ключей, без какой-либо специальной работы с моей стороны. 
Например, у меня есть привязки ключей emacs, настроенные для Chrome и Firefox. Нет никакого способа для скрипта, чтобы обнаружить это. 
    <a class="update" href="#keymap">[это уже не так]</a>
  </p>

  <p>Конечно, поскольку только небольшая часть документа находится в текстовой области, такие клавиши, как page up и ctrl-end, не будут делать правильных вещей. 
CodeMirror ловит эти события и обрабатывает их сам.
  </p>
</section>
<section id="selection"><h2>Выбор</h2>
  <p>Получение и настройка диапазона выделения текстовой области в современных браузерах тривиальны—вы просто используете свойства <code>selectionStart</code> и <code>selectionEnd</code>. 
    В IE вам придется делать какие-то безумные вещи с временными диапазонами и компенсировать тот факт, что перемещение выделения по "символу" будет рассматривать \r\n как один символ, но даже там можно построить функции, которые надежно устанавливают и получают диапазон выделения.
  </p>

  <p>Но рассмотрим этот типичный случай: когда я нахожусь где-то в своем документе, нажимаю shift и нажимаю стрелку вверх, что-то выбирается. 
Затем, если я, все еще удерживая shift, снова нажму стрелку вверх, верхняя часть моего выбора будет скорректирована. 
Выбор запоминает, где находятся его <em>голова</em> и где <em>якорь</em> и перемещает голову, когда мы сдвигаем-перемещаем. 
    Это общепринятое свойство выборок, и сделано правильно каждым компонентом редактирования, построенным за последние двадцать лет.
  </p>
  <p>Но не то, что раскрывают API выбора браузера.</p> 
  <p>Отлично. Поэтому, когда кто-то создает "перевернутую" выборку, в следующий раз, когда CodeMirror должен обновить текстовую область, он повторно создаст выборку как "перевернутую" выборку, с якорем наверху, и следующее движение курсора будет вести себя неожиданным образом-наше второе нажатие стрелки вверх в приведенном выше примере ничего не сделает, так как оно интерпретируется точно так же, как и первое.
  </p>
  <p>Без проблем. Мы просто обнаружим, что выделение перевернуто (вы можете сказать, как оно было создано), а затем, когда присутствует перевернутое выделение и клавиша перемещения курсора нажата в сочетании с shift, мы быстро свернем выделение в текстовой области до его начала, позволим клавише вступить в силу, а затем объединим ее новую головку со старым якорем, чтобы получить <em>реальное</em> выделение.
  </p>
  <p>Короче говоря, страшных взломов полностью избежать в CodeMirror 2 не удалось.</p>
  <p>И, наблюдательный читатель может спросить, как вы вообще знаете, что комбинация клавиш-это комбинация перемещения курсора, если вы утверждаете, что поддерживаете любые собственные привязки клавиш? 
Ну, мы не знаем, но мы можем научиться. Редактор сохраняет набор известных комбинаций перемещения курсора (инициализированных до предсказуемых значений по умолчанию) и обновляет этот набор, когда замечает, что нажатие определенной клавиши имело (только) эффект перемещения курсора. 
Это, конечно, не работает, если в первый раз ключ используется для расширения инвертированного выбора, но он работает большую часть времени.
  </p>
</section>
<section id="update"><h2>Интеллектуальное Обновление</h2>
  <p>Одна вещь, которая всегда возникает, когда у вас есть сложное внутреннее состояние, которое отражается в некотором видимом пользователем внешнем представлении (в данном случае отображаемый код и содержимое текстовой области),-это синхронизация этих двух элементов. 
Наивный способ-просто обновлять дисплей каждый раз, когда вы меняете свое состояние, но это не только подвержено ошибкам (вы забудете), но и легко приводит к дублированию работы над большими составными операциями. 
Затем вы начинаете передавать флаги, указывающие, следует ли обновить дисплей в попытке снова стать эффективным, и в этот момент Вы можете полностью отказаться от этого.
  </p>
  <p>Я действительно пошел по этому пути, но затем переключился на гораздо более простую модель: просто следите за всеми вещами, которые были изменены во время действия, а затем, только в конце, используйте эту информацию для обновления видимого пользователем дисплея.
  </p>
  <p>CodeMirror использует концепцию <em>операций</em>, которые начинаются с вызова определенной функции настройки, которая очищает состояние, и заканчиваются вызовом другой функции, которая считывает это состояние и выполняет необходимое обновление. 
Большинство обработчиков событий и все видимые пользователю методы, изменяющие состояние, обернуты таким образом. 
Существует метод под названием <code>operation</code>, который принимает функцию и возвращает другую функцию, которая обертывает данную функцию как операцию.
  </p>
  <p>Тривиально расширить это (как это делает CodeMirror), чтобы обнаружить вложенность, и, когда операция запускается внутри операции, просто увеличить количество вложенности и выполнить обновление только тогда, когда это количество снова достигнет нуля.
  </p>
  <p>Если у нас есть набор измененных диапазонов и мы знаем текущий показанный диапазон, мы можем (с некоторым неудобным кодом, чтобы иметь дело с тем фактом, что изменения могут добавлять и удалять линии, поэтому мы имеем дело с изменяющейся системой координат) построить карту диапазонов, которые остались нетронутыми. 
Затем мы можем сравнить эту карту с той частью документа, которая в данный момент видна (на основе смещения прокрутки и высоты редактора), чтобы определить, нужно ли что-то обновлять.
  </p>
  <p>CodeMirror использует два алгоритма обновления-полное обновление, когда он просто отбрасывает всю часть DOM, содержащую отредактированный текст, и перестраивает ее, и алгоритм исправления, когда он использует информацию об измененных и неповрежденных диапазонах для обновления только устаревших частей DOM. 
Когда требуется обновить более 30 процентов (что является текущей эвристикой, которая может измениться) строк, выбирается полное обновление (поскольку это быстрее, чем кропотливо находить и обновлять все измененные строки), в другом случае он выполняет исправление (так что, если вы прокручиваете строку или выбираете другой символ, весь экран не нужно повторно визуализировать). 
    <span class="update">[алгоритм полного обновления был отброшен, он не был действительно быстрее, чем исправляющий]</span>
  </p>
  <p>Все обновления используют <code>innerHTML</code>, а не прямую манипуляцию DOM, поскольку это все еще кажется самым быстрым способом создания документов. 
    Существует функция для каждой строки, которая объединяет информацию о выделении, <a href="manual.html#markText">маркировке</a>, и выборе для этой строки фрагмента HTML. 
    Средство обновления исправлений использует его для сброса отдельных строк, средство обновления обновлений создает HTML-фрагмент для всего видимого документа сразу, а затем использует одно обновление <code>innerHTML</code> для выполнения обновления.
  </p>
</section>
<section id="parse"><h2>Парсеры могут быть простыми</h2>
  <p>Когда я писал CodeMirror 1, я думал, что 
    <a href="https://codemirror.net/story.html#parser">прерываемые Парсеры</a> -это чрезвычайно страшная и сложная вещь, и я использовал кучу тяжеловесных абстракций, чтобы держать эту предполагаемую сложность под контролем: Парсеры были 
    <a href="http://bob.pythonmac.org/archives/2005/07/06/iteration-in-javascript/">итераторами</a>, которые потребляли входные данные от другого итератора, и использовали забавные трюки закрытия-сброса, чтобы скопировать и возобновить себя.
  </p>
  <p>Это создавало довольно приятную систему, в которой Парсеры образовывали строго отдельные модули и могли быть составлены предсказуемым образом. 
К сожалению, он был довольно медленным (укладывая три или четыре итератора друг на друга) и чрезвычайно пугающим для людей, не привыкших к функциональному стилю программирования.
  </p>
  <p>Однако с помощью нескольких небольших изменений мы можем сохранить все эти преимущества, но упростить API и сделать все это менее косвенным и неэффективным. 
    <a href="manual.html#modeapi">API режима</a> CodeMirror 2 использует явные объекты состояния и делает синтаксический анализатор/токенизатор функцией, которая просто принимает абстракцию состояния и символьного потока, продвигает токен stream one и возвращает способ, которым должен быть стилизован токен. 
Это состояние может быть скопировано, необязательно в определенном режиме, чтобы иметь возможность продолжить синтаксический анализ в данной точке. 
Даже тот, кто никогда в жизни не касался лямбды, может понять этот подход. Кроме того, теперь в процессе синтаксического анализа выделяется гораздо меньше объектов.
  </p>
  <p>Самое большое ускорение происходит из-за того, что синтаксический анализ больше не должен касаться DOM. 
В CodeMirror 1, в более старом браузере, вы могли <em>видеть</em>, как парсер работает через документ, управляя примерно двадцатью строками в каждом 50-миллисекундном временном срезе, который он получил. 
Он считывал свои входные данные из DOM и обновлял DOM по ходу работы, что любой опытный программист JavaScript сразу же определит как рецепт медлительности. 
В CodeMirror 2 парсер обычно заканчивает весь документ за один 100-миллисекундный временной срез—он управляет примерно 1500 строками в течение этого времени на Chrome. 
Все, что ему нужно сделать, - это мунге-струны, так что нет никакой реальной причины для того, чтобы он больше не был медленным.
  </p>
</section>
<section id="summary"><h2>Что это даёт?</h2>
  <p>Учитывая все это, чего вы можете ожидать от CodeMirror 2?</p>
<ul>

  <li><strong>Маленький.</strong> базовая библиотека сейчас составляет около <span class="update">45k</span>, когда она уменьшена, и <span class="update">17k</span>, когда gzipped. 
    Он меньше, чем его собственный логотип.</li>

  <li><strong>Лёгкий.</strong> CodeMirror 2 инициализируется очень быстро и почти не работает, когда он не сфокусирован. 
    Это означает, что вы можете относиться к нему почти как к текстовой области, иметь несколько экземпляров на странице без проблем.</li>

  <li><strong>Огромная поддержка документов.</strong> Поскольку выделение происходит очень быстро, а структура DOM не строится для невидимого контента, вам не нужно беспокоиться о блокировке вашего браузера, когда пользователь вводит документ размером в мегабайт.</li>

  <li><strong>Расширенный API.</strong> Некоторые вещи продолжали появляться в списке рассылки, такие как маркировка фрагментов текста или строк, что было чрезвычайно трудно сделать с CodeMirror 1. 
    Новая версия имеет надлежащую поддержку для этих встроенных функций.</li>

  <li><strong>Поддержка вкладок.</strong> Вкладки внутри редактируемых документов были по какой-то причине недоступны. 
    По меньшей мере шесть разных людей объявили, что собираются добавить поддержку вкладок в CodeMirror 1, но ни один не выжил (я имею в виду, что ни один не поставил рабочую версию). 
    CodeMirror 2 больше не удаляет вкладки из вашего документа.</li>

  <li><strong>Вменяемый стиль.</strong> узлы <code>iframe</code> на самом деле не известны тем, что уважают документооборот. Теперь, когда экземпляр редактора представляет собой простой <code>div</code>-элемент, гораздо проще изменить его размер, чтобы он соответствовал окружающим элементам. 
    Вам даже не нужно заставлять его прокручиваться, 
    <a href="../demo/resize.html">если вы этого не хотите</a>.</li>

</ul>
  <p>С другой стороны, экземпляр CodeMirror 2 <em>не</em> является собственным редактируемым компонентом. 
    Хотя он делает все возможное, чтобы эмулировать такой компонент как можно больше, есть функциональность, которую браузеры просто не позволяют нам подключать. 
Выполнение select-all из контекстного меню, например, в настоящее время не обнаружено CodeMirror.
  </p>
  <p id="changes" style="margin-top: 2em;"><span style="font-weight: bold">[Обновления от 13 ноября 2011 года]</span> Недавно я внес некоторые изменения в кодовую базу, из-за которых некоторые из приведенных выше текстов больше не являются актуальными. 
Я оставил текст нетронутым, но добавил маркеры в тех местах, которые теперь неточны. Новая ситуация описана ниже.
  </p>
</section>
<section id="btree"><h2>Представление содержания</h2>
  <p>Оригинальная реализация CodeMirror 2 представляла документ в виде плоского массива строковых объектов. 
    При такой работе хорошо распределенных массивов после сращивания потребуется перемещение части массива, но в основном это простое <code>запоминающее перемещение</code> кучки указателей, так что это дешево даже для огромных документов.
  </p>
  <p>Однако недавно я добавил обертывание строк и фальцовку кода (в основном, фальцовка строк). 
Как только строки начинают занимать неограниченное количество вертикального пространства, просмотр строки по вертикали (что необходимо, когда кто-то щелкает по документу, и для определения видимой части документа во время прокрутки) может быть сделано только с линейным сканированием по всему массиву, суммируя высоту строк, как вы идете. 
Видя, как я быстро делаю большие документы, это неприемлемо.
  </p>
  <p>Новое представление основано на B-дереве. 
Листья дерева содержат массивы линейных объектов, с фиксированным минимальным и максимальным размером, а нелистовые узлы просто удерживают массивы дочерних узлов. 
В каждом узле хранится как количество линий, которые живут под ними, так и вертикальное пространство, занимаемое этими линиями. 
Это позволяет индексировать дерево как по номеру строки, так и по вертикали, а весь доступ имеет логарифмическую сложность по отношению к размеру документа.
  </p>
  <p>Я дал объекты линии и узлы дерева родительским указателям, на узел над ними. 
Когда линия должна обновить свою высоту, она может просто подвести эти указатели к вершине дерева, добавляя или вычитая разницу в высоте из каждого узла, с которым она сталкивается. 
Родительские указатели также удешевляют (в документах нормального размера разница, вероятно, крошечная) поиск текущего номера строки при задании объекта строки. 
В старом подходе поиск осуществлялся по всему массиву документов. Теперь мы можем просто подойти к дереву и посчитать размеры узлов, стоящих перед нами на каждом уровне.
  </p>
  <p>Я выбрал B-деревья, а не обычные бинарные деревья, в основном потому, что они допускают очень быстрые объемные вставки и удаления. 
Когда в документ вносятся большие изменения, обычно это подразумевает добавление, удаление или замену фрагмента последующих строк. 
В обычном сбалансированном дереве все эти вставки или удаления должны быть сделаны отдельно, что может быть действительно дорогостоящим. 
В B-дереве, чтобы вставить кусок, вы просто идете вниз по дереву один раз, чтобы найти, куда он должен пойти, вставить их всех в один выстрел, а затем разбить узел, если это необходимо. 
Такое разбиение может включать в себя разбиение узлов еще дальше, но требует всего лишь одного прохода назад по дереву. 
Для удаления, я несколько вялый в поддержании равновесия вещей - я просто разрушаю узлы в лист, когда их ребенок счет идет ниже заданного числа. 
Это означает, что существуют некоторые странные шаблоны редактирования, которые могут привести к серьезному несбалансированному дереву, но даже такое несбалансированное дерево будет работать хорошо, если только вы не потратите день, делая странно повторяющиеся правки в действительно большом документе.
  </p>
</section>
<section id="keymap"><h2>Клавиатуры</h2>
  <p><a href="#approach">Выше</a> я утверждал, что прямая ловля ключевых событий для таких вещей, как движение курсора, непрактична, потому что она требует некоторых специфических для браузера ключей. 
    Затем я продолжил объяснять некоторые ужасные <a href="#selection">взломы</a>, которые были необходимы для того, чтобы изменения в селекции могли быть обнаружены через текстовое поле. 
На самом деле, второй взлом примерно так же плох, как и первый.
  </p>
  <p>Кроме того, при наличии настраиваемых пользователем размеров вкладок и свернутых и обернутых линий, выстраивание движения курсора в текстовом поле с тем, что видно на экране, превращается в кошмар. 
Таким образом, я решил перейти к модели, от которой больше не зависит выбор текста.
  </p>
  <p>Поэтому я перешел на модель, где все движения курсора обрабатываются моим собственным кодом. 
Это добавляет поддержку столбцу цели, правильное взаимодействие движения курсора со свернутыми линиями, а также позволяет вертикальному движению правильно перемещаться по обернутым линиям, вместо того, чтобы просто относиться к ним, как к не обернутым.
  </p>
  <p>Обработчики события ключа теперь переводят событие ключа в строку, что-то вроде <code>Ctrl-Home</code> или <code>Shift-Cmd-R</code>, и используют эту строку для поиска нужного действия.
    Чтобы сделать привязки к клавишам настраиваемыми, этот поиск проходит через <a href="manual.html#option_keyMap">таблицу</a>, используя схему, которая позволяет связать такие таблицы вместе (например, привязки Mac по умолчанию попадают в таблицу под названием 'emacsy', которая определяет базовые привязки в Emacs-стиле, такие как <code>Ctrl-F</code>, и которая также используется в пользовательских привязках Emacs).
  </p>
  <p>Новая опция <a href="manual.html#option_extraKeys"><code>extraKeys</code></a> позволяет определять специальные связки клавиш гораздо приятнее, чем то, что было возможно при старом вызове <a href="manual.html#option_onKeyEvent"><code>onKeyEvent</code></a>. 
    Вы просто предоставляете объекту сопоставление идентификаторов ключей с функциями, вместо того, чтобы кропотливо просматривать необработанные ключевые события.
  </p>
  <p>Встроенные команды сопоставляют строки, а не функции, например <code>"goLineUp"</code> это действие по умолчанию, привязанное к клавише со стрелкой "вверх". 
    Это позволяет новым клавиатурным картам ссылаться на них без дублирования кода. 
    Новые команды можно определить, назначив объект <code>CodeMirror.commands</code>, который сопоставляет такие команды с функциями.
  </p>
  <p>Скрытое текстовое поле теперь содержит только текущее выделение, без лишних символов вокруг него. 
У этого есть хорошее преимущество: Опрос на вход становится намного, намного быстрее. 
Если есть большое выделение, этот текст не обязательно читать из текстовой области каждый раз, когда мы опрашиваем, просто заметить, что что-то все еще выделено, достаточно, чтобы сказать нам, что новый текст не был набран.
  </p>
  <p>Причина, по которой дешевый опрос важен, заключается в том, что многие браузеры не запускают полезные события на входе IME (input method engine), то есть в том, что люди, вводящие такой язык, как японский или китайский, используют несколько нажатий клавиш для создания иероглифа или последовательности иероглифов. 
    Большинство современных браузеров запускают <code>ввод</code> после завершения композиции, но многие ничего не запускают, когда персонаж обновляется <em>во время</em> композиции. 
    Поэтому мы опрашиваем, когда редактор фокусируется, чтобы обеспечить немедленное обновление дисплея.
  </p>
</section>
</article>
